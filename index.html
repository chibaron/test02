<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>STM32 G4 Web Flasher</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #1e1e1e; color: #d4d4d4; padding: 20px; line-height: 1.5; }
        .container { max-width: 900px; margin: auto; background: #252526; padding: 25px; border-radius: 8px; border: 1px solid #444; }
        h2 { color: #569cd6; margin-top: 0; border-bottom: 1px solid #444; }
        .card { background: #333; padding: 15px; border-radius: 6px; margin-bottom: 20px; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        #log { 
            width: 100%; height: 450px; background: #000; color: #bbb; 
            padding: 10px; font-family: 'Consolas', monospace; overflow-y: scroll; 
            white-space: pre-wrap; border: 1px solid #555; font-size: 12px;
        }
        button { 
            padding: 10px 20px; cursor: pointer; border: none; border-radius: 4px; 
            background: #0e639c; color: white; font-weight: bold; width: 100%;
        }
        button:hover { background: #1177bb; }
        button:disabled { background: #444; color: #888; cursor: not-allowed; }
        .success { color: #6a9955; }
        .err { color: #f44747; }
        .tx { color: #4fc1ff; }
        .rx { color: #dcdcaa; }
        .progress-bar { height: 4px; background: #444; margin-top: 10px; border-radius: 2px; }
        #progressFill { height: 100%; background: #0e639c; width: 0%; transition: width 0.1s; }
    </style>
</head>
<body>

<div class="container">
    <h2>STM32 UART Web Flasher</h2>
    
    <div class="card grid">
        <div>
            <label>1. Firmware (.hex)</label><br>
            <input type="file" id="hexFile" accept=".hex" style="margin-top:5px;">
        </div>
        <div>
            <label>2. Serial Port</label><br>
            <button id="connectBtn">Connect Device</button>
        </div>
    </div>

    <button id="flashBtn" disabled style="background: #2d8a49; font-size: 1.2em;">START FLASHING</button>
    <div class="progress-bar"><div id="progressFill"></div></div>

    <div style="margin-top: 20px;">
        <div id="log"></div>
    </div>
</div>

<script>
/**
 * STM32 Bootloader Web Implementation
 */
const BOOT_CMD = {
    GET_ID: 0x02,
    WRITE_MEMORY: 0x31,
    EXTENDED_ERASE: 0x44,
    ACK: 0x79,
    NACK: 0x1F
};

const G4_CONF = {
    FLASH_BASE: 0x08000000,
    PAGE_SIZE: 2048,
    WRITE_CHUNK: 32 // PythonのWRITE_CHUNK_SIZEに合わせる
};

let port, writer, reader;
let rxBuffer = [];

// --- Utils ---
const sleep = (ms) => new Promise(res => setTimeout(res, ms));
const calcCS = (data) => data.reduce((a, b) => a ^ b, 0) & 0xFF;
function mspCRC(data) {
    let crc = 0;
    for (let b of data) {
        crc ^= b;
        for (let i = 0; i < 8; i++) {
            crc = (crc & 0x80) ? (crc << 1) ^ 0xD5 : crc << 1;
        }
    }
    return crc & 0xFF;
}

function debugLog(msg, type = '') {
    const log = document.getElementById('log');
    const div = document.createElement('div');
    div.className = type;
    div.textContent = `[${new Date().toLocaleTimeString('ja-JP', {hour12:false})}] ${msg}`;
    log.appendChild(div);
    log.scrollTop = log.scrollHeight;
}

// --- Serial Core ---
async function readLoop() {
    try {
        while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            rxBuffer.push(...value);
            // デバッグ用に生データを出す場合はここを有効化
            // console.log("RX Raw:", value);
        }
    } catch (e) { debugLog("Read Error: " + e.message, "err"); }
}

async function waitACK(timeout = 2000) {
    const start = Date.now();
    while (Date.now() - start < timeout) {
        if (rxBuffer.length > 0) {
            const b = rxBuffer.shift();
            if (b === BOOT_CMD.ACK) return true;
            if (b === BOOT_CMD.NACK) { debugLog("Received NACK", "err"); return false; }
        }
        await sleep(5);
    }
    return false;
}

// --- Intel HEX Parser ---
function parseHex(text) {
    const lines = text.split(/\r?\n/);
    let memory = new Map();
    let minAddr = 0xFFFFFFFF, maxAddr = 0, baseAddr = 0;

    for (let line of lines) {
        if (!line.startsWith(':')) continue;
        const len = parseInt(line.substring(1, 3), 16);
        const offset = parseInt(line.substring(3, 7), 16);
        const type = parseInt(line.substring(7, 9), 16);
        if (type === 0x00) {
            const abs = baseAddr + offset;
            const data = line.substring(9, 9 + len * 2).match(/.{1,2}/g).map(h => parseInt(h, 16));
            data.forEach((b, i) => memory.set(abs + i, b));
            minAddr = Math.min(minAddr, abs);
            maxAddr = Math.max(maxAddr, abs + len);
        } else if (type === 0x04) {
            baseAddr = parseInt(line.substring(9, 13), 16) << 16;
        }
    }
    return { memory, minAddr, maxAddr };
}

// --- Main Flow ---
document.getElementById('connectBtn').onclick = async () => {
    try {
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });
        writer = port.writable.getWriter();
        reader = port.readable.getReader();
        readLoop();
        debugLog("Serial Connected", "success");
        document.getElementById('flashBtn').disabled = false;
    } catch (e) { debugLog("Connection Error: " + e.message, "err"); }
};

document.getElementById('flashBtn').onclick = async () => {
    const file = document.getElementById('hexFile').files[0];
    if (!file) return;

    try {
        const { memory, minAddr, maxAddr } = parseHex(await file.text());
        debugLog(`HEX Loaded: 0x${minAddr.toString(16)} - 0x${maxAddr.toString(16)}`, "info");
        rxBuffer = [];

        // 2 & 3. MSP Passthrough & Bootloader Start
        debugLog("Step 2-3: Entering Bootloader via MSP...");
        const mspP = [0x24, 0x58, 0x3C, 0x00, 0xF5, 0x00, 0x02, 0x00, 0xFE, 0x11];
        mspP.push(mspCRC(mspP.slice(3, 10)));
        await writer.write(new Uint8Array(mspP));
        await sleep(1000);

        const mspB = [0x24, 0x58, 0x3C, 0x00, 0x44, 0x00, 0x00, 0x00];
        mspB.push(mspCRC(mspB.slice(3, 8)));
        await writer.write(new Uint8Array(mspB));
        await sleep(1500);
        rxBuffer = []; // Clear junk

        // 5. Synchronize
        debugLog("Step 5: Syncing...");
        let synced = false;
        for(let i=0; i<5; i++) {
            await writer.write(new Uint8Array([0x7F]));
            if (await waitACK(500)) { synced = true; break; }
        }
        if (!synced) throw new Error("Sync Failed");

        // 6. Get ID
        await writer.write(new Uint8Array([BOOT_CMD.GET_ID, BOOT_CMD.GET_ID ^ 0xFF]));
        if (!await waitACK()) throw new Error("Get ID Failed");
        const idLen = (await (async () => { while(rxBuffer.length === 0) await sleep(5); return rxBuffer.shift(); })());
        const idData = [];
        for(let i=0; i<=idLen; i++) idData.push(rxBuffer.shift());
        await waitACK();
        debugLog(`Device ID: 0x${idData.map(b=>b.toString(16)).join('')}`, "success");

        // 7 & 8. Erase Pages (Python同様、1ページずつ実行)
        const startPage = Math.floor((minAddr - G4_CONF.FLASH_BASE) / G4_CONF.PAGE_SIZE);
        const endPage = Math.floor((maxAddr - G4_CONF.FLASH_BASE - 1) / G4_CONF.PAGE_SIZE);
        debugLog(`Step 8: Erasing Pages ${startPage} to ${endPage}...`);

        for (let p = startPage; p <= endPage; p++) {
            await writer.write(new Uint8Array([BOOT_CMD.EXTENDED_ERASE, BOOT_CMD.EXTENDED_ERASE ^ 0xFF]));
            if (!await waitACK()) throw new Error("Erase Cmd NACK");

            const payload = [0x00, 0x00, (p >> 8) & 0xFF, p & 0xFF];
            await writer.write(new Uint8Array([...payload, calcCS(payload)]));
            if (!await waitACK(5000)) throw new Error(`Erase Page ${p} Failed`);
            
            if (p % 10 === 0) debugLog(`Erasing... ${p}/${endPage}`);
        }
        debugLog("Erase Complete", "success");
        await sleep(500);

        // 9. Write Firmware
        debugLog("Step 9: Writing Firmware...");
        const totalSize = maxAddr - minAddr;
        let written = 0;

        for (let addr = minAddr; addr < maxAddr; addr += G4_CONF.WRITE_CHUNK) {
            const chunk = [];
            for (let j = 0; j < G4_CONF.WRITE_CHUNK; j++) {
                chunk.push(memory.get(addr + j) ?? 0xFF);
            }

            // Write Command
            await writer.write(new Uint8Array([BOOT_CMD.WRITE_MEMORY, BOOT_CMD.WRITE_MEMORY ^ 0xFF]));
            if (!await waitACK()) throw new Error("Write Cmd NACK");

            // Address
            const aB = [(addr >> 24) & 0xFF, (addr >> 16) & 0xFF, (addr >> 8) & 0xFF, addr & 0xFF];
            await writer.write(new Uint8Array([...aB, calcCS(aB)]));
            if (!await waitACK()) throw new Error(`Addr NACK at 0x${addr.toString(16)}`);

            // Data
            const dPL = [chunk.length - 1, ...chunk];
            await writer.write(new Uint8Array([...dPL, calcCS(dPL)]));
            if (!await waitACK()) throw new Error(`Data NACK at 0x${addr.toString(16)}`);

            written += G4_CONF.WRITE_CHUNK;
            document.getElementById('progressFill').style.width = `${(written/totalSize)*100}%`;
        }

        debugLog("FLASH SUCCESS!", "success");
        alert("書き込み完了！");

    } catch (e) {
        debugLog("FATAL: " + e.message, "err");
        console.error(e);
    }
};
</script>
</body>
</html>
