<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>STM32 G4 Web Flasher (Python Logic Sync)</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #1e1e1e; color: #d4d4d4; padding: 20px; line-height: 1.5; }
        .container { max-width: 900px; margin: auto; background: #252526; padding: 25px; border-radius: 8px; border: 1px solid #444; }
        h2 { color: #569cd6; margin-top: 0; border-bottom: 1px solid #444; }
        .card { background: #333; padding: 15px; border-radius: 6px; margin-bottom: 20px; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        #log { 
            width: 100%; height: 400px; background: #000; color: #bbb; 
            padding: 10px; font-family: 'Consolas', monospace; overflow-y: scroll; 
            white-space: pre-wrap; border: 1px solid #555; font-size: 12px;
        }
        button { 
            padding: 10px 20px; cursor: pointer; border: none; border-radius: 4px; 
            background: #0e639c; color: white; font-weight: bold; width: 100%;
        }
        button:hover { background: #1177bb; }
        button:disabled { background: #444; color: #888; cursor: not-allowed; }
        
        /* インジケータの強化 */
        .progress-container { 
            height: 24px; background: #444; margin: 15px 0; border-radius: 12px; 
            overflow: hidden; position: relative; border: 1px solid #555;
        }
        #progressFill { 
            height: 100%; background: linear-gradient(90deg, #0e639c, #1177bb); 
            width: 0%; transition: width 0.1s ease; display: flex; align-items: center; justify-content: center;
        }
        #progressText {
            position: absolute; width: 100%; text-align: center; left: 0; top: 0;
            line-height: 24px; font-size: 12px; font-weight: bold; color: white; text-shadow: 1px 1px 2px black;
        }

        .success { color: #6a9955; }
        .err { color: #f44747; }
        .info { color: #888; }
        .step { color: #569cd6; font-weight: bold; }
    </style>
</head>
<body>

<div class="container">
    <h2>STM32 UART Web Flasher</h2>
    
    <div class="card grid">
        <div>
            <label>1. Firmware Selection (.hex)</label><br>
            <input type="file" id="hexFile" accept=".hex" style="margin-top:5px;">
        </div>
        <div>
            <label>2. Device Connection</label><br>
            <button id="connectBtn">Connect Serial Port</button>
        </div>
    </div>

    <button id="flashBtn" disabled style="background: #2d8a49; font-size: 1.1em; height: 50px;">START FLASHING</button>
    
    <div class="progress-container">
        <div id="progressFill"></div>
        <div id="progressText">0%</div>
    </div>

    <div id="log"></div>
</div>

<script>
const BOOT_CMD = { GET_ID: 0x02, WRITE_MEMORY: 0x31, EXTENDED_ERASE: 0x44, ACK: 0x79, NACK: 0x1F };
const G4_CONF = { FLASH_BASE: 0x08000000, PAGE_SIZE: 2048, WRITE_CHUNK: 32 };

let port, writer, reader, rxBuffer = [];

const sleep = (ms) => new Promise(res => setTimeout(res, ms));
const calcCS = (data) => data.reduce((a, b) => a ^ b, 0) & 0xFF;

function mspCRC(data) {
    let crc = 0;
    for (let b of data) {
        crc ^= b;
        for (let i = 0; i < 8; i++) {
            crc = (crc & 0x80) ? (crc << 1) ^ 0xD5 : crc << 1;
        }
    }
    return crc & 0xFF;
}

function debugLog(msg, type = '') {
    const log = document.getElementById('log');
    const div = document.createElement('div');
    div.className = type;
    div.textContent = `[${new Date().toLocaleTimeString('ja-JP', {hour12:false})}] ${msg}`;
    log.appendChild(div);
    log.scrollTop = log.scrollHeight;
}

async function readLoop() {
    try {
        while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            rxBuffer.push(...value);
        }
    } catch (e) { debugLog("Read Error: " + e.message, "err"); }
}

async function waitACK(timeout = 2000) {
    const start = Date.now();
    while (Date.now() - start < timeout) {
        if (rxBuffer.length > 0) {
            const b = rxBuffer.shift();
            if (b === BOOT_CMD.ACK) return true;
            if (b === BOOT_CMD.NACK) return false;
        }
        await sleep(5);
    }
    return false;
}

function parseHex(text) {
    const lines = text.split(/\r?\n/);
    let memory = new Map(), minAddr = 0xFFFFFFFF, maxAddr = 0, baseAddr = 0;
    for (let line of lines) {
        if (!line.startsWith(':')) continue;
        const len = parseInt(line.substring(1, 3), 16);
        const offset = parseInt(line.substring(3, 7), 16);
        const type = parseInt(line.substring(7, 9), 16);
        if (type === 0x00) {
            const abs = baseAddr + offset;
            const data = line.substring(9, 9 + len * 2).match(/.{1,2}/g).map(h => parseInt(h, 16));
            data.forEach((b, i) => memory.set(abs + i, b));
            minAddr = Math.min(minAddr, abs);
            maxAddr = Math.max(maxAddr, abs + len);
        } else if (type === 0x04) {
            baseAddr = parseInt(line.substring(9, 13), 16) << 16;
        }
    }
    return { memory, minAddr, maxAddr };
}

document.getElementById('connectBtn').onclick = async () => {
    try {
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });
        writer = port.writable.getWriter();
        reader = port.readable.getReader();
        readLoop();
        debugLog("Serial Connected", "success");
        document.getElementById('flashBtn').disabled = false;
    } catch (e) { debugLog("Error: " + e.message, "err"); }
};

document.getElementById('flashBtn').onclick = async () => {
    const file = document.getElementById('hexFile').files[0];
    if (!file) return;

    try {
        const { memory, minAddr, maxAddr } = parseHex(await file.text());
        debugLog(`Firmware: 0x${minAddr.toString(16).toUpperCase()} to 0x${maxAddr.toString(16).toUpperCase()}`, "info");
        rxBuffer = [];

        // --- Step 2 & 3: MSP Commands ---
        debugLog("Setting up Serial Passthrough...", "step");
        let p = [0x24, 0x58, 0x3C, 0x00, 0xF5, 0x00, 0x02, 0x00, 0xFE, 0x11];
        p.push(mspCRC(p.slice(3, 10)));
        await writer.write(new Uint8Array(p));
        await sleep(1000);

        debugLog("Entering Bootloader mode...", "step");
        let b = [0x24, 0x58, 0x3C, 0x00, 0x44, 0x00, 0x00, 0x00];
        b.push(mspCRC(b.slice(3, 8)));
        await writer.write(new Uint8Array(b));
        await sleep(1500);
        rxBuffer = [];

        // --- Step 5: Sync ---
        debugLog("Synchronizing...", "step");
        let synced = false;
        for(let i=0; i<5; i++) {
            await writer.write(new Uint8Array([0x7F]));
            if (await waitACK(500)) { synced = true; break; }
        }
        if (!synced) throw new Error("Synchronization failed.");

        // --- Step 6: Get ID ---
        await writer.write(new Uint8Array([BOOT_CMD.GET_ID, BOOT_CMD.GET_ID ^ 0xFF]));
        if (!await waitACK()) throw new Error("Get ID command failed.");
        const idLen = (await (async () => { while(rxBuffer.length === 0) await sleep(5); return rxBuffer.shift(); })());
        for(let i=0; i<=idLen; i++) rxBuffer.shift(); // Consume ID bytes
        await waitACK();

        // --- Step 7 & 8: Erase (One by one like Python) ---
        const startPage = Math.floor((minAddr - G4_CONF.FLASH_BASE) / G4_CONF.PAGE_SIZE);
        const endPage = Math.floor((maxAddr - G4_CONF.FLASH_BASE - 1) / G4_CONF.PAGE_SIZE);
        const totalPages = endPage - startPage + 1;
        debugLog(`Erasing ${totalPages} pages (${startPage}-${endPage})...`, "step");

        for (let p = startPage; p <= endPage; p++) {
            await writer.write(new Uint8Array([BOOT_CMD.EXTENDED_ERASE, BOOT_CMD.EXTENDED_ERASE ^ 0xFF]));
            if (!await waitACK()) throw new Error("Erase command NACK");
            const payload = [0x00, 0x00, (p >> 8) & 0xFF, p & 0xFF];
            await writer.write(new Uint8Array([...payload, calcCS(payload)]));
            if (!await waitACK(5000)) throw new Error(`Erase failed at page ${p}`);
        }
        debugLog("Erase completed.", "success");
        await sleep(500);

        // --- Step 9: Write ---
        debugLog("Starting Firmware Write...", "step");
        const totalSize = maxAddr - minAddr;
        let written = 0;
        let lastLogPercent = -10;

        for (let addr = minAddr; addr < maxAddr; addr += G4_CONF.WRITE_CHUNK) {
            const chunk = [];
            for (let j = 0; j < G4_CONF.WRITE_CHUNK; j++) {
                chunk.push(memory.get(addr + j) ?? 0xFF);
            }

            // Command
            await writer.write(new Uint8Array([BOOT_CMD.WRITE_MEMORY, BOOT_CMD.WRITE_MEMORY ^ 0xFF]));
            if (!await waitACK()) throw new Error("Write Cmd NACK");

            // Address
            const aB = [(addr >> 24) & 0xFF, (addr >> 16) & 0xFF, (addr >> 8) & 0xFF, addr & 0xFF];
            await writer.write(new Uint8Array([...aB, calcCS(aB)]));
            if (!await waitACK()) throw new Error(`Address NACK at 0x${addr.toString(16)}`);

            // Data
            const dPL = [chunk.length - 1, ...chunk];
            await writer.write(new Uint8Array([...dPL, calcCS(dPL)]));
            if (!await waitACK()) throw new Error(`Data NACK at 0x${addr.toString(16)}`);

            written += chunk.length;
            const percent = Math.floor((written / totalSize) * 100);
            
            // UI Update
            document.getElementById('progressFill').style.width = `${percent}%`;
            document.getElementById('progressText').textContent = `${percent}%`;

            // Log Progress every 10%
            if (percent >= lastLogPercent + 10) {
                debugLog(`Progress: ${percent}% (${written} / ${totalSize} bytes)`);
                lastLogPercent = percent;
            }
        }

        debugLog("FLASH COMPLETED SUCCESSFULLY!", "success");
        document.getElementById('progressFill').style.background = "#2d8a49";
        alert("書き込みが完了しました。");

    } catch (e) {
        debugLog("FATAL ERROR: " + e.message, "err");
    }
};
</script>
</body>
</html>
