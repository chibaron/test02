<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>STM32 G4 Web Flasher - Professional Edition</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #1e1e1e; color: #d4d4d4; padding: 20px; line-height: 1.5; }
        .container { max-width: 1000px; margin: auto; background: #252526; padding: 25px; border-radius: 8px; border: 1px solid #444; }
        h2 { color: #569cd6; margin-top: 0; border-bottom: 1px solid #444; padding-bottom: 10px; }
        .card { background: #333; padding: 15px; border-radius: 6px; margin-bottom: 20px; border: 1px solid #444; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        
        #log { 
            width: 100%; height: 500px; background: #000; color: #dcdcdc; 
            padding: 12px; font-family: 'Consolas', 'Monaco', monospace; overflow-y: scroll; 
            white-space: pre-wrap; border: 1px solid #333; font-size: 11.5px; line-height: 1.4;
        }

        .tx { color: #4fc1ff; } 
        .rx { color: #dcdcaa; } 
        .success { color: #6a9955; font-weight: bold; }
        .err { color: #f44747; font-weight: bold; }
        .info { color: #808080; }
        .step { color: #ce9178; font-weight: bold; border-left: 3px solid #ce9178; padding-left: 8px; margin-top: 10px; display: block; }

        button { 
            padding: 12px; cursor: pointer; border: none; border-radius: 4px; 
            background: #0e639c; color: white; font-weight: bold; width: 100%; transition: 0.2s;
        }
        button:hover { background: #1177bb; }
        button:disabled { background: #3a3d41; color: #757575; cursor: not-allowed; }
        
        .progress-container { 
            height: 30px; background: #333; margin: 15px 0; border-radius: 4px; 
            overflow: hidden; position: relative; border: 1px solid #555;
        }
        #progressFill { 
            height: 100%; background: #2d8a49; width: 0%; transition: width 0.1s ease; 
        }
        #progressText {
            position: absolute; width: 100%; text-align: center; left: 0; top: 0;
            line-height: 30px; font-size: 14px; font-weight: bold; color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
    </style>
</head>
<body>

<div class="container">
    <h2>STM32 UART Web Flasher <small style="font-size: 0.5em; color: #888;">Verbose Debug Mode</small></h2>
    
    <div class="card grid">
        <div>
            <label>1. Select Firmware (.hex)</label><br>
            <input type="file" id="hexFile" accept=".hex" style="margin-top:8px;">
        </div>
        <div>
            <label>2. Device Control</label><br>
            <button id="connectBtn">CONNECT SERIAL PORT</button>
        </div>
    </div>

    <button id="flashBtn" disabled style="background: #2d8a49; height: 50px; font-size: 1.2em;">START FLASHING</button>
    
    <div class="progress-container">
        <div id="progressFill"></div>
        <div id="progressText">0%</div>
    </div>

    <div id="log"></div>
</div>

<script>
const BOOT_CMD = { GET_ID: 0x02, WRITE_MEMORY: 0x31, EXTENDED_ERASE: 0x44, ACK: 0x79, NACK: 0x1F };
const G4_CONF = { FLASH_BASE: 0x08000000, PAGE_SIZE: 2048, WRITE_CHUNK: 32 };

let port, writer, reader, readIteration = true;
let rxBuffer = [];

const sleep = (ms) => new Promise(res => setTimeout(res, ms));
const calcCS = (data) => data.reduce((a, b) => a ^ b, 0) & 0xFF;
const toHex = (arr) => Array.from(arr).map(b => b.toString(16).toUpperCase().padStart(2, '0')).join(' ');

function mspCRC(data) {
    let crc = 0;
    for (let b of data) {
        crc ^= b;
        for (let i = 0; i < 8; i++) {
            crc = (crc & 0x80) ? (crc << 1) ^ 0xD5 : crc << 1;
        }
    }
    return crc & 0xFF;
}

function debugLog(msg, type = '') {
    const log = document.getElementById('log');
    const div = document.createElement('div');
    div.className = type;
    const now = new Date().toLocaleTimeString('en-US', { hour12: false, fractionDigits: 3 });
    div.textContent = `[${now}] ${msg}`;
    log.appendChild(div);
    log.scrollTop = log.scrollHeight;
}

async function writeAndLog(data) {
    debugLog(`TX > ${toHex(data)}`, 'tx');
    await writer.write(new Uint8Array(data));
}

async function readLoop() {
    try {
        while (readIteration) {
            const { value, done } = await reader.read();
            if (done) break;
            if (value) {
                debugLog(`RX < ${toHex(value)}`, 'rx');
                rxBuffer.push(...value);
            }
        }
    } catch (e) { 
        if (readIteration) debugLog("READ LOOP ERROR: " + e.message, "err"); 
    } finally {
        if (reader) reader.releaseLock();
    }
}

async function waitACK(timeout = 2000) {
    const start = Date.now();
    while (Date.now() - start < timeout) {
        if (rxBuffer.length > 0) {
            const b = rxBuffer.shift();
            if (b === BOOT_CMD.ACK) return true;
            if (b === BOOT_CMD.NACK) {
                debugLog("!! NACK (0x1F) RECEIVED !!", "err");
                return false;
            }
        }
        await sleep(5);
    }
    debugLog("!! TIMEOUT WAITING FOR ACK !!", "err");
    return false;
}

async function closePort() {
    debugLog("Closing serial port and releasing resources...", "info");
    readIteration = false; 
    try {
        if (reader) await reader.cancel();
        if (writer) writer.releaseLock();
        if (port) await port.close();
        debugLog("PORT CLOSED SUCCESSFULLY.", "success");
    } catch (e) {
        debugLog("ERROR DURING DISCONNECTION: " + e.message, "err");
    }
    document.getElementById('flashBtn').disabled = true;
    port = null; writer = null; reader = null;
}

function parseHex(text) {
    const lines = text.split(/\r?\n/);
    let memory = new Map(), minAddr = 0xFFFFFFFF, maxAddr = 0, baseAddr = 0;
    for (let line of lines) {
        line = line.trim();
        if (!line.startsWith(':')) continue;
        const len = parseInt(line.substring(1, 3), 16);
        const offset = parseInt(line.substring(3, 7), 16);
        const type = parseInt(line.substring(7, 9), 16);
        if (type === 0x00) {
            const abs = baseAddr + offset;
            const data = line.substring(9, 9 + len * 2).match(/.{1,2}/g).map(h => parseInt(h, 16));
            data.forEach((b, i) => memory.set(abs + i, b));
            minAddr = Math.min(minAddr, abs);
            maxAddr = Math.max(maxAddr, abs + len);
        } else if (type === 0x04) {
            baseAddr = parseInt(line.substring(9, 13), 16) << 16;
        }
    }
    return { memory, minAddr, maxAddr };
}

document.getElementById('connectBtn').onclick = async () => {
    try {
        rxBuffer = [];
        readIteration = true;
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });
        writer = port.writable.getWriter();
        reader = port.readable.getReader();
        readLoop();
        debugLog("SERIAL PORT CONNECTED.", "success");
        document.getElementById('flashBtn').disabled = false;
    } catch (e) { debugLog("CONNECTION ERROR: " + e.message, "err"); }
};

document.getElementById('flashBtn').onclick = async () => {
    const file = document.getElementById('hexFile').files[0];
    if (!file || !port) return;

    try {
        debugLog("--- STARTING FLASH SEQUENCE ---", "step");
        const { memory, minAddr, maxAddr } = parseHex(await file.text());
        debugLog(`HEX DATA: MinAddr=0x${minAddr.toString(16)}, MaxAddr=0x${maxAddr.toString(16)}, Size=${maxAddr-minAddr} bytes`, "info");

        // --- MSP Passthrough ---
        debugLog("STEP 1: INITIALIZING SERIAL PASSTHROUGH (MSP)", "step");
        let p = [0x24, 0x58, 0x3C, 0x00, 0xF5, 0x00, 0x02, 0x00, 0xFE, 0x11];
        p.push(mspCRC(p.slice(3, 10)));
        await writeAndLog(p);
        await sleep(1000);

        // --- MSP Bootloader Start ---
        debugLog("STEP 2: ACTIVATING SYSTEM BOOTLOADER", "step");
        let b = [0x24, 0x58, 0x3C, 0x00, 0x44, 0x00, 0x00, 0x00];
        b.push(mspCRC(b.slice(3, 8)));
        await writeAndLog(b);
        debugLog("Waiting 1500ms for MCU hardware reset...", "info");
        await sleep(1500);
        rxBuffer = []; 

        // --- Sync ---
        debugLog("STEP 3: STM32 BOOTLOADER SYNCHRONIZATION", "step");
        let synced = false;
        for(let i=0; i<5; i++) {
            debugLog(`SYNC ATTEMPT ${i+1}...`);
            await writer.write(new Uint8Array([0x7F]));
            if (await waitACK(500)) { synced = true; break; }
        }
        if (!synced) throw new Error("SYNC FAILED: NO ACK RECEIVED FROM 0x7F.");
        debugLog("SYNCHRONIZATION SUCCESSFUL.", "success");

        // --- Get ID ---
        debugLog("STEP 4: READING DEVICE IDENTIFIER", "step");
        await writeAndLog([BOOT_CMD.GET_ID, BOOT_CMD.GET_ID ^ 0xFF]);
        if (!await waitACK()) throw new Error("GET_ID COMMAND REJECTED.");
        
        while(rxBuffer.length < 1) await sleep(10);
        const idLen = rxBuffer.shift();
        const idData = [];
        for(let i=0; i<=idLen; i++) {
            while(rxBuffer.length < 1) await sleep(10);
            idData.push(rxBuffer.shift());
        }
        await waitACK(); 
        debugLog(`TARGET DEVICE PID: 0x${toHex(idData)}`, "success");

        // --- Erase ---
        const startPage = Math.floor((minAddr - G4_CONF.FLASH_BASE) / G4_CONF.PAGE_SIZE);
        const endPage = Math.floor((maxAddr - G4_CONF.FLASH_BASE - 1) / G4_CONF.PAGE_SIZE);
        const totalPages = endPage - startPage + 1;
        debugLog(`STEP 5: ERASING FLASH MEMORY (${totalPages} PAGES)`, "step");

        for (let p = startPage; p <= endPage; p++) {
            debugLog(`ERASING PAGE ${p}...`);
            await writeAndLog([BOOT_CMD.EXTENDED_ERASE, BOOT_CMD.EXTENDED_ERASE ^ 0xFF]);
            if (!await waitACK()) throw new Error(`ERASE CMD REJECTED AT PAGE ${p}`);
            
            const payload = [0x00, 0x00, (p >> 8) & 0xFF, p & 0xFF];
            await writeAndLog([...payload, calcCS(payload)]);
            if (!await waitACK(5000)) throw new Error(`ERASE TIMEOUT AT PAGE ${p}`);
        }
        debugLog("FLASH ERASE COMPLETED.", "success");
        await sleep(500);

        // --- Write ---
        debugLog("STEP 6: WRITING FIRMWARE DATA", "step");
        const totalSize = maxAddr - minAddr;
        let written = 0;
        let lastLogPercent = -10;

        for (let addr = minAddr; addr < maxAddr; addr += G4_CONF.WRITE_CHUNK) {
            const chunk = [];
            for (let j = 0; j < G4_CONF.WRITE_CHUNK; j++) {
                chunk.push(memory.get(addr + j) ?? 0xFF);
            }

            // Write CMD
            await writeAndLog([BOOT_CMD.WRITE_MEMORY, BOOT_CMD.WRITE_MEMORY ^ 0xFF]);
            if (!await waitACK()) throw new Error("WRITE COMMAND REJECTED.");

            // Address
            const aB = [(addr >> 24) & 0xFF, (addr >> 16) & 0xFF, (addr >> 8) & 0xFF, addr & 0xFF];
            await writeAndLog([...aB, calcCS(aB)]);
            if (!await waitACK()) throw new Error(`ADDRESS 0x${addr.toString(16)} REJECTED.`);

            // Data
            const dPL = [chunk.length - 1, ...chunk];
            await writeAndLog([...dPL, calcCS(dPL)]);
            if (!await waitACK()) throw new Error(`DATA PAYLOAD REJECTED AT 0x${addr.toString(16)}`);

            written += chunk.length;
            const percent = Math.floor((written / totalSize) * 100);
            document.getElementById('progressFill').style.width = `${percent}%`;
            document.getElementById('progressText').textContent = `${percent}% (${written}/${totalSize} BYTES)`;

            if (percent >= lastLogPercent + 10) {
                debugLog(`--- WRITE PROGRESS: ${percent}% ---`, "info");
                lastLogPercent = percent;
            }
        }

        debugLog("FLASH PROCESS COMPLETED SUCCESSFULLY!", "success");
        alert("FLASHING COMPLETED! DISCONNECTING PORT.");

    } catch (e) {
        debugLog("FATAL FLASH ERROR: " + e.message, "err");
        alert("ERROR: " + e.message);
    } finally {
        await closePort();
    }
};
</script>
</body>
</html>
