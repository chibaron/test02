<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>STM32 Web Flasher (Fix Version)</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #2c3e50; color: white; padding: 20px; }
        .container { max-width: 900px; margin: auto; background: #34495e; padding: 25px; border-radius: 10px; }
        #log { 
            width: 100%; height: 450px; background: #1e1e1e; color: #00ff00; 
            padding: 15px; font-family: 'Consolas', monospace; overflow-y: scroll; 
            white-space: pre-wrap; border: 1px solid #555; font-size: 13px; box-sizing: border-box;
        }
        .tx { color: #5dade2; } .rx { color: #f4d03f; } .err { color: #e74c3c; font-weight: bold; }
        .success { color: #2ecc71; font-weight: bold; } .step { color: #ffffff; background: #2980b9; padding: 2px 5px; }
        .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px; }
        button { padding: 12px; cursor: pointer; border: none; border-radius: 5px; background: #2980b9; color: white; font-weight: bold; }
        button:disabled { background: #7f8c8d; }
    </style>
</head>
<body>
<div class="container">
    <h2>STM32 UART Web Flasher</h2>
    <div class="controls">
        <input type="file" id="hexFile" accept=".hex">
        <button id="connectBtn">① シリアルポートを選択</button>
        <button id="flashBtn" disabled style="grid-column: span 2; background: #27ae60;">② 書き込み開始</button>
    </div>
    <div id="log"></div>
    <button id="clearLogBtn" style="margin-top:10px; background:#e67e22;">ログ消去</button>
</div>

<script>
window.addEventListener('DOMContentLoaded', () => {
    const FLASH_BASE = 0x08000000;
    const WRITE_CHUNK = 256;
    let port, writer;
    let rxBuffer = []; // 受信データを溜めるバッファ

    const logDiv = document.getElementById('log');

    function debugLog(message, type = 'info') {
        const span = document.createElement('span');
        if (type === 'tx') span.className = 'tx';
        else if (type === 'rx') span.className = 'rx';
        else if (type === 'err') span.className = 'err';
        else if (type === 'success') span.className = 'success';
        else if (type === 'step') span.className = 'step';
        span.textContent = `[${new Date().toLocaleTimeString('ja-JP',{hour12:false,fractionDigits:3})}] ${message}\n`;
        logDiv.appendChild(span);
        logDiv.scrollTop = logDiv.scrollHeight;
    }

    // 常時受信ループ：届いたデータは即座にrxBufferへ入れる
    async function startReading(reader) {
        try {
            while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                if (value) {
                    debugLog(`RX < ${Array.from(value).map(b => b.toString(16).toUpperCase().padStart(2,'0')).join(' ')}`, 'rx');
                    rxBuffer.push(...value); // 全受信データをバッファに保存
                }
            }
        } catch (e) { console.error(e); }
        finally { reader.releaseLock(); }
    }

    // 指定したバイトが届くまで待つ関数
    async function waitResponse(targetByte, timeout = 2000) {
        const start = Date.now();
        while (Date.now() - start < timeout) {
            if (rxBuffer.length > 0) {
                const b = rxBuffer.shift(); // バッファの先頭を取り出す
                if (b === targetByte) return true;
            }
            await new Promise(r => setTimeout(r, 1)); // 1ms待機して再チェック
        }
        return false;
    }

    const sleep = (ms) => new Promise(res => setTimeout(res, ms));
    const calcCS = (data) => data.reduce((a, b) => a ^ b, 0) & 0xFF;
    const mspCRC = (data) => {
        let crc = 0;
        for (let b of data) {
            crc ^= b;
            for (let i = 0; i < 8; i++) {
                crc = (crc & 0x80) ? (crc << 1) ^ 0xD5 : crc << 1;
            }
        }
        return crc & 0xFF;
    };

    document.getElementById('connectBtn').onclick = async () => {
        try {
            port = await navigator.serial.requestPort();
            await port.open({ baudRate: 115200 });
            writer = port.writable.getWriter();
            startReading(port.readable.getReader()); // 受信ループ開始
            debugLog("Serial Connected.", "success");
            document.getElementById('flashBtn').disabled = false;
        } catch (e) { debugLog(`Error: ${e}`, "err"); }
    };

    document.getElementById('flashBtn').onclick = async () => {
        const file = document.getElementById('hexFile').files[0];
        if (!file) return alert("HEXファイルを選択してください");

        try {
            const hexText = await file.text();
            const firmware = parseHex(hexText);
            rxBuffer = []; // バッファをクリア

            debugLog("Step 2: MSP Passthrough", "step");
            let p = [0x24, 0x58, 0x3C, 0x00, 0xF5, 0x00, 0x02, 0x00, 0xFE, 0x11];
            p.push(mspCRC(p.slice(3, 10)));
            await writer.write(new Uint8Array(p));
            debugLog(`TX > ${p.map(b=>b.toString(16).toUpperCase().padStart(2,'0')).join(' ')}`, "tx");
            await sleep(1000);

            debugLog("Step 3: MSP Bootloader Start", "step");
            let b = [0x24, 0x58, 0x3C, 0x00, 0x44, 0x00, 0x00, 0x00];
            b.push(mspCRC(b.slice(3, 8)));
            await writer.write(new Uint8Array(b));
            debugLog(`TX > ${b.map(x=>x.toString(16).toUpperCase().padStart(2,'0')).join(' ')}`, "tx");
            await sleep(1500);
            rxBuffer = []; // リブート時のゴミを捨てる

            debugLog("Step 4: Synchronizing (0x7F)", "step");
            let synced = false;
            for(let i=0; i<5; i++) {
                await writer.write(new Uint8Array([0x7F]));
                if (await waitResponse(0x79, 500)) { synced = true; break; }
                debugLog(`Retry Sync... ${i+1}`, "info");
            }
            if (!synced) throw new Error("Sync Failed (ACK 0x79 not received)");

            debugLog("Step 5: Get ID", "step");
            await writer.write(new Uint8Array([0x02, 0xFD]));
            if (!await waitResponse(0x79)) throw new Error("Get ID NACK");

            // --- Step 6: Erase ---
            debugLog("Step 6: Erasing...", "step");
            // Extended Erase コマンド送信
            const eraseCmd = [0x44, 0xBB];
            await writer.write(new Uint8Array(eraseCmd));
            debugLog(`TX > ${eraseCmd.map(b=>b.toString(16).toUpperCase().padStart(2,'0')).join(' ')}`, "tx");
            
            if (await waitResponse(0x79)) {
                debugLog("ACK received for Erase Command. Sending Global Erase...", "info");
                // Global Erase パラメータ送信 (0xFFFF + Checksum 0x00)
                const globalEraseParams = [0xFF, 0xFF, 0x00];
                await writer.write(new Uint8Array(globalEraseParams));
                debugLog(`TX > ${globalEraseParams.map(b=>b.toString(16).toUpperCase().padStart(2,'0')).join(' ')}`, "tx");
                
                debugLog("Waiting for erase to complete (this may take a few seconds)...", "info");
                if (!await waitResponse(0x79, 10000)) { // 消去は長いので10秒待機
                    throw new Error("Erase Timeout or NACK");
                }
                debugLog("Erase Successful.", "success");
            } else {
                throw new Error("Erase Command NACK");
            }

            // --- Step 7: Write Memory ---
            debugLog("Step 7: Writing Firmware...", "step");
            for (let i = 0; i < firmware.length; i += WRITE_CHUNK) {
                const chunk = firmware.slice(i, i + WRITE_CHUNK);
                const addr = FLASH_BASE + i;
                
                // A. Write Command
                await writer.write(new Uint8Array([0x31, 0xCE]));
                // TXログが多すぎると重くなるため、最初の1回や区切りだけ出す設定もアリですが、
                // デバッグのため一旦出します
                if (!await waitResponse(0x79)) throw new Error(`Write Cmd NACK at ${addr.toString(16)}`);

                // B. Address + Checksum
                const addrBytes = [(addr >> 24) & 0xFF, (addr >> 16) & 0xFF, (addr >> 8) & 0xFF, addr & 0xFF];
                const addrPayload = [...addrBytes, calcCS(addrBytes)];
                await writer.write(new Uint8Array(addrPayload));
                if (!await waitResponse(0x79)) throw new Error(`Addr NACK at ${addr.toString(16)}`);

                // C. Data + Checksum
                const lenByte = chunk.length - 1;
                const dataPayload = [lenByte, ...chunk];
                const dataWithCS = [...dataPayload, calcCS(dataPayload)];
                await writer.write(new Uint8Array(dataWithCS));
                if (!await waitResponse(0x79)) throw new Error(`Data NACK at ${addr.toString(16)}`);

                if (i % 1024 === 0 || i + WRITE_CHUNK >= firmware.length) {
                    debugLog(`Progress: ${Math.round((i / firmware.length) * 100)}% (${i}/${firmware.length} bytes)`, "info");
                }
            }
            debugLog("DONE!", "success");
        } catch (e) { debugLog(`Error: ${e.message}`, "err"); }
    };

    function parseHex(hex) {
        const bin = [];
        hex.split(/\r?\n/).forEach(line => {
            if (line.trim().startsWith(':') && line.substring(7,9) === '00') {
                const bytes = line.substring(9, line.length - 3).match(/.{1,2}/g).map(h => parseInt(h, 16));
                bin.push(...bytes);
            }
        });
        return new Uint8Array(bin);
    }
    document.getElementById('clearLogBtn').onclick = () => logDiv.innerHTML = '';
});
</script>
</body>
</html>