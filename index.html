<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>MSP v2 Web Serial Debug Tool</title>

  <style>
    body {
      background: #111;
      color: #0f0;
      font-family: monospace;
      margin: 20px;
    }

    h2, h3 {
      margin-bottom: 10px;
    }

    button {
      background: #222;
      color: #0f0;
      border: 1px solid #0f0;
      padding: 6px 12px;
      cursor: pointer;
    }

    button:disabled {
      opacity: 0.5;
      cursor: default;
    }

    #log, #bootlog {
      background: #000;
      border: 1px solid #0f0;
      padding: 10px;
      height: 300px;
      overflow-y: auto;
      white-space: pre-wrap;
      margin-top: 10px;
    }

    input[type="file"] {
      margin-top: 6px;
    }
  </style>
</head>

<body>
  <h2>MSP v2 Web Serial Debug Tool</h2>

  <button id="connect">Connect & Send MSP</button>

  <pre id="log"></pre>

  <hr>

  <h3>STM32 Bootloader (HEX Download)</h3>
  <input type="file" id="hexFile" accept=".hex">
  <button id="sendHex">Send HEX</button>

  <pre id="bootlog"></pre>

  <script>
    /* =========================
       Globals
    ========================= */

    let port;
    let writer;

    const logEl = document.getElementById("log");
    const bootlogEl = document.getElementById("bootlog");

    function log(text) {
      logEl.textContent += text;
      logEl.scrollTop = logEl.scrollHeight;
    }

    function blog(text) {
      bootlogEl.textContent += text + "\n";
      bootlogEl.scrollTop = bootlogEl.scrollHeight;
    }

    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    function hexDump(bytes) {
      let out = "";
      for (let i = 0; i < bytes.length; i++) {
        if (i % 16 === 0) {
          out += "\n" + i.toString(16).padStart(4, "0") + ": ";
        }
        out += bytes[i].toString(16).padStart(2, "0") + " ";
      }
      return out;
    }

    function asciiDump(bytes) {
      return Array.from(bytes)
        .map(b => (b >= 0x20 && b <= 0x7E) ? String.fromCharCode(b) : ".")
        .join("");
    }

    /* =========================
       CRC-8/D5 (MSP v2)
    ========================= */

    function crc8_d5(bytes) {
      let crc = 0x00;
      for (const b of bytes) {
        crc ^= b;
        for (let i = 0; i < 8; i++) {
          crc = (crc & 0x80) ? ((crc << 1) ^ 0xD5) : (crc << 1);
          crc &= 0xFF;
        }
      }
      return crc;
    }

    /* =========================
       MSP Send
    ========================= */

    async function sendMSP(payload, label) {
      log(`\n>>> SEND ${label} (${payload.length} bytes)`);
      log(hexDump(payload) + "\n");
      await writer.write(payload);
    }

    /* =========================
       Intel HEX Parser
    ========================= */

    function parseHex(text) {
      const lines = text.trim().split(/\r?\n/);
      let upper = 0;
      const records = [];

      for (const line of lines) {
        if (!line.startsWith(":")) continue;

        const len  = parseInt(line.substr(1, 2), 16);
        const addr = parseInt(line.substr(3, 4), 16);
        const type = parseInt(line.substr(7, 2), 16);

        if (type === 0x04) {
          upper = parseInt(line.substr(9, 4), 16) << 16;
        } else if (type === 0x00) {
          const data = [];
          for (let i = 0; i < len; i++) {
            data.push(parseInt(line.substr(9 + i * 2, 2), 16));
          }
          records.push({
            address: upper + addr,
            data
          });
        }
      }
      return records;
    }

    /* =========================
       STM32 Bootloader (UART)
    ========================= */

    function xorChecksum(arr) {
      return arr.reduce((a, b) => a ^ b, 0x00);
    }

    async function stm32WriteMemory(address, data) {
      // CMD
      await writer.write(new Uint8Array([0x31, 0xCE]));

      // Address
      const addr = [
        (address >> 24) & 0xFF,
        (address >> 16) & 0xFF,
        (address >> 8) & 0xFF,
        address & 0xFF
      ];
      await writer.write(new Uint8Array([...addr, xorChecksum(addr)]));

      // Length + data
      const payload = [data.length - 1, ...data];
      await writer.write(new Uint8Array([...payload, xorChecksum(payload)]));
    }

    /* =========================
       UI Handlers
    ========================= */

    document.getElementById("connect").onclick = async () => {
      try {
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });
        writer = port.writable.getWriter();

        log("=== Serial Connected ===\n");

        const reader = port.readable.getReader();
        (async function readLoop() {
          while (true) {
            try {
              const { value, done } = await reader.read();
              if (done) break;
              if (value) {
                log(`\n<<< RECV (${value.length} bytes)`);
                log(hexDump(value));
                log("\nASCII: " + asciiDump(value) + "\n");
              }
            } catch (e) {
              log("\nRead error: " + e + "\n");
              break;
            }
          }
        })();

        await sleep(1000);

        const msp1 = [
          0x24, 0x58, 0x3C,
          0x00, 0xF5,
          0x00, 0x02,
          0x00, 0xFE, 0x11
        ];
        msp1.push(crc8_d5(msp1.slice(3)));
        await sendMSP(new Uint8Array(msp1), "MSP #1");

        await sleep(1000);

        const msp2 = [
          0x24, 0x58, 0x3C,
          0x00, 0x44,
          0x00, 0x00,
          0x00
        ];
        msp2.push(crc8_d5(msp2.slice(3)));
        await sendMSP(new Uint8Array(msp2), "MSP #2");

      } catch (e) {
        log("\nERROR: " + e + "\n");
      }
    };

    document.getElementById("sendHex").onclick = async () => {
      const file = document.getElementById("hexFile").files[0];
      if (!file || !writer) {
        blog("HEX file or serial not ready");
        return;
      }

      const text = await file.text();
      const records = parseHex(text);

      blog(`HEX records: ${records.length}`);

      for (const r of records) {
        blog(`Write 0x${r.address.toString(16)} (${r.data.length} bytes)`);
        await stm32WriteMemory(r.address, r.data);
        await sleep(5);
      }

      blog("HEX download completed");
    };
  </script>
</body>
</html>
