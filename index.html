<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>STM32 Web Flasher (GitHub Release Integration)</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #1e1e1e; color: #d4d4d4; padding: 20px; }
        .container { max-width: 900px; margin: auto; background: #252526; padding: 25px; border-radius: 10px; border: 1px solid #444; }
        #log { 
            width: 100%; height: 400px; background: #000; color: #dcdcdc; 
            padding: 15px; font-family: 'Consolas', monospace; overflow-y: scroll; 
            white-space: pre-wrap; border: 1px solid #333; font-size: 12.5px; margin-top: 15px;
        }
        .tx { color: #4fc1ff; } .rx { color: #dcdcaa; } .err { color: #f44747; font-weight: bold; }
        .success { color: #6a9955; font-weight: bold; } .step { color: #ffffff; background: #007acc; padding: 2px 6px; }
        .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px; }
        .control-group { display: flex; flex-direction: column; gap: 8px; border: 1px solid #333; padding: 15px; border-radius: 5px; }
        label { font-size: 0.9em; font-weight: bold; color: #569cd6; }
        button { padding: 12px; cursor: pointer; border: none; border-radius: 4px; background: #0e639c; color: white; font-weight: bold; }
        button:disabled { background: #3a3d41; color: #757575; }
        select, input[type="file"] { background: #3c3c3c; color: #ccc; padding: 8px; border: 1px solid #555; }
    </style>
</head>
<body>

<div class="container">
    <h2>STM32 UART Web Flasher</h2>
    
    <div class="controls">
        <div class="control-group">
            <label>1. GitHub Release (OpenOSD-X)</label>
            <select id="releaseSelect">
                <option value="">-- リリースを取得中... --</option>
            </select>
            <button id="fetchBtn" style="padding: 5px; font-size: 0.8em; background: #444;">再読み込み</button>
        </div>

        <div class="control-group">
            <label>OR: Local HEX File</label>
            <input type="file" id="hexFile" accept=".hex">
        </div>

        <div class="control-group" style="grid-column: span 2;">
            <button id="connectBtn">Connect Serial Port</button>
            <button id="flashBtn" disabled style="margin-top:10px; background: #2d8a49;">START FLASHING</button>
        </div>
    </div>

    <div id="log"></div>
    <button id="clearLogBtn" style="margin-top:10px; background:#444; width:100%;">Clear Log</button>
</div>

<script>
window.addEventListener('DOMContentLoaded', async () => {
    const REPO = "OpenOSD-X/OpenOSD-X";
    let port, writer, rxBuffer = [];
    const logDiv = document.getElementById('log');
    const releaseSelect = document.getElementById('releaseSelect');

    function debugLog(message, type = 'info') {
        const span = document.createElement('span');
        span.className = type;
        span.textContent = `[${new Date().toLocaleTimeString('ja-JP', {hour12:false, fractionDigits:3})}] ${message}\n`;
        logDiv.appendChild(span);
        logDiv.scrollTop = logDiv.scrollHeight;
    }

    // --- GitHub Releases 取得 ---
    async function fetchReleases() {
        try {
            releaseSelect.innerHTML = '<option value="">-- 読込中 --</option>';
            const res = await fetch(`https://api.github.com/repos/${REPO}/releases`);
            const releases = await res.json();
            
            releaseSelect.innerHTML = '<option value="">-- GitHubから選択 --</option>';
            releases.forEach(rel => {
                rel.assets.forEach(asset => {
                    if (asset.name.endsWith('.hex')) {
                        const opt = document.createElement('option');
                        opt.value = asset.browser_download_url;
                        opt.textContent = `${rel.tag_name} - ${asset.name}`;
                        releaseSelect.appendChild(opt);
                    }
                });
            });
            if (releaseSelect.options.length <= 1) {
                releaseSelect.innerHTML = '<option value="">HEXファイルが見つかりません</option>';
            }
        } catch (e) {
            debugLog("GitHubからの取得に失敗しました: " + e.message, "err");
        }
    }

    // --- HEX パース (前回同様) ---
    function parseHex(hexText) {
        const lines = hexText.split(/\r?\n/);
        let memory = new Map(), minAddr = 0xFFFFFFFF, maxAddr = 0, baseAddr = 0;
        for (let line of lines) {
            line = line.trim(); if (!line.startsWith(':')) continue;
            const len = parseInt(line.substring(1, 3), 16), offset = parseInt(line.substring(3, 7), 16), type = parseInt(line.substring(7, 9), 16);
            if (type === 0x00) {
                const absAddr = baseAddr + offset;
                const bytes = line.substring(9, 9 + (len * 2)).match(/.{1,2}/g).map(h => parseInt(h, 16));
                bytes.forEach((b, i) => memory.set(absAddr + i, b));
                minAddr = Math.min(minAddr, absAddr); maxAddr = Math.max(maxAddr, absAddr + len);
            } else if (type === 0x04) baseAddr = parseInt(line.substring(9, 13), 16) << 16;
        }
        const firmware = new Uint8Array(maxAddr - minAddr);
        for (let i = 0; i < firmware.length; i++) firmware[i] = memory.get(minAddr + i) ?? 0xFF;
        return { firmware, minAddr, maxAddr };
    }

    // --- シリアル通信ヘルパー ---
    async function startReading(reader) {
        try { while (true) { const { value, done } = await reader.read(); if (done) break; if (value) { 
            debugLog(`RX < ${Array.from(value).map(b => b.toString(16).toUpperCase().padStart(2,'0')).join(' ')}`, 'rx');
            rxBuffer.push(...value); 
        } } } catch (e) {}
    }

    async function waitResponse(targetByte, timeout = 2000) {
        const start = Date.now();
        while (Date.now() - start < timeout) {
            if (rxBuffer.length > 0) { const b = rxBuffer.shift(); if (b === targetByte) return true; if (b === 0x1F) return false; }
            await new Promise(r => setTimeout(r, 5));
        }
        return false;
    }

    const sleep = (ms) => new Promise(res => setTimeout(res, ms));
    const calcCS = (data) => data.reduce((a, b) => a ^ b, 0) & 0xFF;

    // --- イベント ---
    document.getElementById('fetchBtn').onclick = fetchReleases;
    
    document.getElementById('connectBtn').onclick = async () => {
        try {
            port = await navigator.serial.requestPort();
            await port.open({ baudRate: 115200 });
            writer = port.writable.getWriter();
            startReading(port.readable.getReader());
            debugLog("Serial Connected.", "success");
            document.getElementById('flashBtn').disabled = false;
        } catch (e) { debugLog("Error: " + e, "err"); }
    };

    document.getElementById('flashBtn').onclick = async () => {
        let hexText = "";
        const localFile = document.getElementById('hexFile').files[0];
        const remoteUrl = releaseSelect.value;

        try {
            if (localFile) {
                hexText = await localFile.text();
                debugLog(`Loading Local File: ${localFile.name}`, "info");
            } else if (remoteUrl) {
                debugLog(`Downloading from GitHub: ${remoteUrl}`, "info");
                const res = await fetch(remoteUrl);
                hexText = await res.text();
            } else {
                alert("HEXファイルを選択してください"); return;
            }

            const { firmware, minAddr, maxAddr } = parseHex(hexText);
            rxBuffer = [];

            // --- 以降、書き込みロジック (前回の安定版) ---
            debugLog("Step 2-4: Entering Bootloader Mode", "step");
            await writer.write(new Uint8Array([0x24,0x58,0x3C,0x00,0xF5,0x00,0x02,0x00,0xFE,0x11,0x12]));
            await sleep(1000);
            await writer.write(new Uint8Array([0x24,0x58,0x3C,0x00,0x44,0x00,0x00,0x00,0x06]));
            await sleep(2000);
            rxBuffer = [];

            await writer.write(new Uint8Array([0x7F]));
            if (!await waitResponse(0x79)) throw new Error("Sync Failed");

            debugLog("Step 6: Erasing...", "step");
            const PAGE_SIZE = 2048;
            const startP = Math.floor((minAddr - 0x08000000) / PAGE_SIZE);
            const endP = Math.floor((maxAddr - 0x08000000 - 1) / PAGE_SIZE);
            let pList = []; for(let i=startP; i<=endP; i++) pList.push(i);

            await writer.write(new Uint8Array([0x44, 0xBB]));
            await waitResponse(0x79);
            let ePL = [(pList.length-1 >> 8) & 0xFF, (pList.length-1) & 0xFF];
            pList.forEach(p => { ePL.push((p >> 8) & 0xFF); ePL.push(p & 0xFF); });
            await writer.write(new Uint8Array([...ePL, calcCS(ePL)]));
            if (!await waitResponse(0x79, 15000)) throw new Error("Erase Timeout");

            await sleep(1500); // 安定待ち

            debugLog("Step 7: Writing...", "step");
            const CHUNK = 128;
            for (let i = 0; i < firmware.length; i += CHUNK) {
                let chunk = firmware.slice(i, i + CHUNK);
                if (chunk.length % 8 !== 0) {
                    let tmp = new Uint8Array(Math.ceil(chunk.length / 8) * 8).fill(0xFF);
                    tmp.set(chunk); chunk = tmp;
                }
                const addr = minAddr + i;
                await writer.write(new Uint8Array([0x31, 0xCE])); await waitResponse(0x79);
                const aB = [(addr >> 24) & 0xFF, (addr >> 16) & 0xFF, (addr >> 8) & 0xFF, addr & 0xFF];
                await writer.write(new Uint8Array([...aB, calcCS(aB)]));
                if (!await waitResponse(0x79)) throw new Error(`Addr NACK at 0x${addr.toString(16)}`);
                const dPL = [chunk.length - 1, ...chunk];
                await writer.write(new Uint8Array([...dPL, calcCS(dPL)]));
                if (!await waitResponse(0x79)) throw new Error("Data NACK");
                if (i % 4096 === 0) debugLog(`Progress: ${Math.round((i/firmware.length)*100)}%`);
            }
            debugLog("--- FLASH SUCCESSFUL ---", "success");
        } catch (e) { debugLog(`FATAL: ${e.message}`, "err"); }
    };

    fetchReleases(); // 起動時にリリースを取得
    document.getElementById('clearLogBtn').onclick = () => logDiv.innerHTML = '';
});
</script>
</body>
</html>
