<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>STM32 Web Flasher (HEX Address Auto-Calc)</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #1e1e1e; color: #d4d4d4; padding: 20px; }
        .container { max-width: 1000px; margin: auto; background: #252526; padding: 25px; border-radius: 12px; border: 1px solid #444; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        h2 { color: #569cd6; border-bottom: 1px solid #444; padding-bottom: 10px; margin-top: 0; }
        .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px; }
        .control-group { display: flex; flex-direction: column; gap: 8px; }
        #log { 
            width: 100%; height: 500px; background: #000; color: #dcdcdc; 
            padding: 15px; font-family: 'Consolas', 'Monaco', monospace; overflow-y: scroll; 
            white-space: pre-wrap; border: 1px solid #333; font-size: 12.5px; line-height: 1.4;
        }
        .tx { color: #4fc1ff; } /* Blue: Transmit */
        .rx { color: #dcdcaa; } /* Yellow: Receive */
        .err { color: #f44747; font-weight: bold; }
        .success { color: #6a9955; font-weight: bold; }
        .step { color: #ffffff; background: #007acc; padding: 2px 6px; border-radius: 3px; font-size: 0.9em; }
        .info { color: #808080; }
        button { 
            padding: 12px; cursor: pointer; border: none; border-radius: 4px; 
            background: #0e639c; color: white; font-weight: bold; transition: 0.2s;
        }
        button:hover { background: #1177bb; }
        button:disabled { background: #3a3d41; color: #757575; cursor: not-allowed; }
        input[type="file"] { background: #3c3c3c; color: #ccc; padding: 8px; border: 1px solid #555; border-radius: 4px; }
    </style>
</head>
<body>

<div class="container">
    <h2>STM32 UART Web Flasher <small style="font-size:0.5em; color:#888;">(Debug Mode)</small></h2>
    
    <div class="controls">
        <div class="control-group">
            <label>1. Firmware Selection</label>
            <input type="file" id="hexFile" accept=".hex">
        </div>
        <div class="control-group">
            <label>2. Device Connection</label>
            <button id="connectBtn">Connect Serial Port</button>
        </div>
        <div class="control-group" style="grid-column: span 2;">
            <button id="flashBtn" disabled style="background: #2d8a49; width: 100%;">START FLASHING</button>
        </div>
    </div>

    <div id="log"></div>
    <button id="clearLogBtn" style="margin-top:10px; background:#444; width:100%; font-size: 0.8em;">Clear Console Log</button>
</div>

<script>
/**
 * STM32 Web Serial Flasher Logic
 */
window.addEventListener('DOMContentLoaded', () => {
    let port, writer;
    let rxBuffer = []; // Global buffer for incoming bytes

    const logDiv = document.getElementById('log');
    const flashBtn = document.getElementById('flashBtn');

    // --- Logger ---
    function debugLog(message, type = 'info') {
        const span = document.createElement('span');
        span.className = type;
        const now = new Date().toLocaleTimeString('ja-JP', { hour12: false, fractionDigits: 3 });
        span.textContent = `[${now}] ${message}\n`;
        logDiv.appendChild(span);
        logDiv.scrollTop = logDiv.scrollHeight;
    }

    // --- Intel HEX Parser ---
    function parseHex(hexText) {
        const lines = hexText.split(/\r?\n/);
        let memory = new Map();
        let minAddr = 0xFFFFFFFF;
        let maxAddr = 0;
        let baseAddr = 0;

        for (let line of lines) {
            line = line.trim();
            if (!line.startsWith(':')) continue;

            const len = parseInt(line.substring(1, 3), 16);
            const offset = parseInt(line.substring(3, 7), 16);
            const type = parseInt(line.substring(7, 9), 16);
            const dataStr = line.substring(9, 9 + (len * 2));

            if (type === 0x00) { // Data Record
                const absAddr = baseAddr + offset;
                const bytes = dataStr.match(/.{1,2}/g).map(h => parseInt(h, 16));
                for (let i = 0; i < bytes.length; i++) {
                    memory.set(absAddr + i, bytes[i]);
                }
                if (absAddr < minAddr) minAddr = absAddr;
                if (absAddr + len > maxAddr) maxAddr = absAddr + len;
            } else if (type === 0x04) { // Extended Linear Address
                baseAddr = parseInt(line.substring(9, 13), 16) << 16;
            }
        }

        const size = maxAddr - minAddr;
        const firmware = new Uint8Array(size);
        for (let i = 0; i < size; i++) {
            firmware[i] = memory.get(minAddr + i) ?? 0xFF;
        }
        return { firmware, minAddr, maxAddr };
    }

    // --- Serial Helpers ---
    async function startReading(reader) {
        try {
            while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                if (value) {
                    debugLog(`RX < ${Array.from(value).map(b => b.toString(16).toUpperCase().padStart(2,'0')).join(' ')}`, 'rx');
                    rxBuffer.push(...value);
                }
            }
        } catch (e) { console.error("Read Loop Error:", e); }
    }

    async function waitResponse(targetByte, timeout = 2000) {
        const start = Date.now();
        while (Date.now() - start < timeout) {
            if (rxBuffer.length > 0) {
                const b = rxBuffer.shift();
                if (b === targetByte) return true;
                if (b === 0x1F) { debugLog("RX < 1F (NACK received)", "err"); return false; }
            }
            await new Promise(r => setTimeout(r, 5));
        }
        return false;
    }

    const sleep = (ms) => new Promise(res => setTimeout(res, ms));
    const calcCS = (data) => data.reduce((a, b) => a ^ b, 0) & 0xFF;

    function mspCRC(data) {
        let crc = 0;
        for (let b of data) {
            crc ^= b;
            for (let i = 0; i < 8; i++) {
                crc = (crc & 0x80) ? (crc << 1) ^ 0xD5 : crc << 1;
            }
        }
        return crc & 0xFF;
    }

    // --- Buttons ---
    document.getElementById('connectBtn').onclick = async () => {
        try {
            port = await navigator.serial.requestPort();
            await port.open({ baudRate: 115200 });
            writer = port.writable.getWriter();
            startReading(port.readable.getReader());
            debugLog("Serial Connected.", "success");
            flashBtn.disabled = false;
        } catch (e) { debugLog(`Connection Error: ${e}`, "err"); }
    };

    flashBtn.onclick = async () => {
        const fileInput = document.getElementById('hexFile');
        if (!fileInput.files.length) return alert("HEXファイルを選択してください");

        try {
            const hexText = await fileInput.files[0].text();
            const { firmware, minAddr, maxAddr } = parseHex(hexText);
            rxBuffer = []; // Clear buffer

            debugLog(`Parsed HEX: Address 0x${minAddr.toString(16).toUpperCase()} to 0x${maxAddr.toString(16).toUpperCase()}`, "info");

            // --- Step 2: MSP Passthrough ---
            debugLog("Step 2: MSP Passthrough", "step");
            let p = [0x24, 0x58, 0x3C, 0x00, 0xF5, 0x00, 0x02, 0x00, 0xFE, 0x11];
            p.push(mspCRC(p.slice(3, 10)));
            await writer.write(new Uint8Array(p));
            await sleep(800);

            // --- Step 3: MSP Bootloader Start ---
            debugLog("Step 3: MSP Bootloader Start", "step");
            let b = [0x24, 0x58, 0x3C, 0x00, 0x44, 0x00, 0x00, 0x00];
            b.push(mspCRC(b.slice(3, 8)));
            await writer.write(new Uint8Array(b));
            debugLog("Waiting for device reboot...", "info");
            await sleep(2000);
            rxBuffer = []; // Discard reboot garbage

            // --- Step 4: Sync ---
            debugLog("Step 4: Synchronizing (0x7F)", "step");
            let synced = false;
            for(let i=0; i<5; i++) {
                await writer.write(new Uint8Array([0x7F]));
                if (await waitResponse(0x79, 500)) { synced = true; break; }
                debugLog(`Sync Retry ${i+1}...`, "info");
            }
            if (!synced) throw new Error("Synchronization failed.");

            // --- Step 5: Get ID ---
            debugLog("Step 5: Get Device ID", "step");
            await writer.write(new Uint8Array([0x02, 0xFD]));
            if (!await waitResponse(0x79)) throw new Error("Get ID NACK");

            // --- Step 6: Erase ---
            debugLog("Step 6: Erasing Pages", "step");
            const PAGE_SIZE = 2048;
            const FLASH_START = 0x08000000;
            const startPage = Math.floor((minAddr - FLASH_START) / PAGE_SIZE);
            const endPage = Math.floor((maxAddr - FLASH_START - 1) / PAGE_SIZE);
            let pages = [];
            for (let i = startPage; i <= endPage; i++) pages.push(i);

            debugLog(`Target: Page ${startPage} to ${endPage} (${pages.length} pages)`, "info");

            await writer.write(new Uint8Array([0x44, 0xBB]));
            if (!await waitResponse(0x79)) throw new Error("Erase Command NACK");

            const numPagesMinusOne = pages.length - 1;
            let erasePayload = [(numPagesMinusOne >> 8) & 0xFF, numPagesMinusOne & 0xFF];
            for (let page of pages) {
                erasePayload.push((page >> 8) & 0xFF);
                erasePayload.push(page & 0xFF);
            }
            const cs = calcCS(erasePayload);
            await writer.write(new Uint8Array([...erasePayload, cs]));
            debugLog(`TX > Erase Payload (CS: 0x${cs.toString(16).toUpperCase()})`, "tx");
            
            if (!await waitResponse(0x79, 30000)) throw new Error("Erase Timeout/NACK");
            debugLog("Erase Successful.", "success");

            // ★追加：消去後にチップが内部処理を終えるのを待つ
            debugLog("Waiting for flash controller to stabilize (2s)...", "info");
            await sleep(2000);

            // --- Step 7: Writing Memory (Alignment Fix) ---
            debugLog("Step 7: Writing Memory", "step");
            const CHUNK = 128; // 256より安定しやすい128バイトに変更（8の倍数）
            
            for (let i = 0; i < firmware.length; i += CHUNK) {
                const curAddr = minAddr + i;
                const chunk = firmware.slice(i, i + CHUNK);

                // 1. Write Command 送信
                await writer.write(new Uint8Array([0x31, 0xCE]));
                if (!await waitResponse(0x79)) {
                    debugLog("Write Command (0x31) rejected. Try 0x11?", "err");
                    throw new Error("CMD NACK");
                }

                // 2. Address 送信
                const aB = [
                    (curAddr >> 24) & 0xFF,
                    (curAddr >> 16) & 0xFF,
                    (curAddr >> 8) & 0xFF,
                    curAddr & 0xFF
                ];
                const addrChecksum = calcCS(aB);
                
                // ★ Python のように一括ではなく、少し丁寧に送ってみる
                await writer.write(new Uint8Array([...aB, addrChecksum]));
                
                // アドレスに対するレスポンスを待つ
                if (!await waitResponse(0x79)) {
                    debugLog(`Address 0x${curAddr.toString(16).toUpperCase()} rejected.`, "err");
                    debugLog("Check: Is this address erased? Is it within flash bounds?", "info");
                    throw new Error("Addr NACK");
                }

                // 3. Data 送信
                const dataLenByte = chunk.length - 1;
                const dataPayload = [dataLenByte, ...chunk];
                const dataChecksum = calcCS(dataPayload);
                
                await writer.write(new Uint8Array([...dataPayload, dataChecksum]));
                if (!await waitResponse(0x79)) throw new Error("Data NACK");

                if (i % 2048 === 0) debugLog(`Progress: ${i}/${firmware.length}`);
            }

            debugLog("--- FLASH COMPLETED SUCCESSFULLY ---", "success");
            alert("書き込みが完了しました！");

        } catch (e) {
            debugLog(`FATAL ERROR: ${e.message}`, "err");
        }
    };

    document.getElementById('clearLogBtn').onclick = () => logDiv.innerHTML = '';
});
</script>
</body>
</html>

