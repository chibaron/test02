<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>STM32 Web Flasher (Quiet Mode)</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #1e1e1e; color: #d4d4d4; padding: 20px; }
        .container { max-width: 900px; margin: auto; background: #252526; padding: 25px; border-radius: 10px; border: 1px solid #444; }
        #log { 
            width: 100%; height: 500px; background: #000; color: #dcdcdc; 
            padding: 15px; font-family: 'Consolas', monospace; overflow-y: scroll; 
            white-space: pre-wrap; border: 1px solid #333; font-size: 12.5px;
        }
        .tx { color: #4fc1ff; } .rx { color: #dcdcaa; } .err { color: #f44747; font-weight: bold; }
        .success { color: #6a9955; font-weight: bold; } .step { color: #ffffff; background: #007acc; padding: 2px 6px; }
        .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px; }
        button { padding: 12px; cursor: pointer; border: none; border-radius: 4px; background: #0e639c; color: white; font-weight: bold; }
        button:disabled { background: #3a3d41; color: #757575; }
        input[type="file"] { background: #3c3c3c; color: #ccc; padding: 8px; border: 1px solid #555; }
    </style>
</head>
<body>

<div class="container">
    <h2>STM32 UART Web Flasher</h2>
    <div class="controls">
        <input type="file" id="hexFile" accept=".hex">
        <button id="connectBtn">Connect Serial Port</button>
        <button id="flashBtn" disabled style="grid-column: span 2; background: #2d8a49;">START FLASHING</button>
    </div>
    <div id="log"></div>
    <button id="clearLogBtn" style="margin-top:10px; background:#444; width:100%;">Clear Log</button>
</div>

<script>
window.addEventListener('DOMContentLoaded', () => {
    let port, writer;
    let rxBuffer = [];
    const logDiv = document.getElementById('log');

    function debugLog(message, type = 'info') {
        const span = document.createElement('span');
        span.className = type;
        span.textContent = `[${new Date().toLocaleTimeString('ja-JP', {hour12:false, fractionDigits:3})}] ${message}\n`;
        logDiv.appendChild(span);
        logDiv.scrollTop = logDiv.scrollHeight;
    }

    function parseHex(hexText) {
        const lines = hexText.split(/\r?\n/);
        let memory = new Map();
        let minAddr = 0xFFFFFFFF, maxAddr = 0, baseAddr = 0;
        for (let line of lines) {
            line = line.trim();
            if (!line.startsWith(':')) continue;
            const len = parseInt(line.substring(1, 3), 16);
            const offset = parseInt(line.substring(3, 7), 16);
            const type = parseInt(line.substring(7, 9), 16);
            if (type === 0x00) {
                const absAddr = baseAddr + offset;
                const bytes = line.substring(9, 9 + (len * 2)).match(/.{1,2}/g).map(h => parseInt(h, 16));
                bytes.forEach((b, i) => memory.set(absAddr + i, b));
                minAddr = Math.min(minAddr, absAddr);
                maxAddr = Math.max(maxAddr, absAddr + len);
            } else if (type === 0x04) baseAddr = parseInt(line.substring(9, 13), 16) << 16;
        }
        const firmware = new Uint8Array(maxAddr - minAddr);
        for (let i = 0; i < firmware.length; i++) firmware[i] = memory.get(minAddr + i) ?? 0xFF;
        return { firmware, minAddr, maxAddr };
    }

    async function startReading(reader) {
        try {
            while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                if (value) {
                    debugLog(`RX < ${Array.from(value).map(b => b.toString(16).toUpperCase().padStart(2,'0')).join(' ')}`, 'rx');
                    rxBuffer.push(...value);
                }
            }
        } catch (e) {}
    }

    async function waitResponse(targetByte, timeout = 2000) {
        const start = Date.now();
        while (Date.now() - start < timeout) {
            if (rxBuffer.length > 0) {
                const b = rxBuffer.shift();
                if (b === targetByte) return true;
                if (b === 0x1F) return false;
            }
            await new Promise(r => setTimeout(r, 5));
        }
        return false;
    }

    const sleep = (ms) => new Promise(res => setTimeout(res, ms));
    const calcCS = (data) => data.reduce((a, b) => a ^ b, 0) & 0xFF;

    document.getElementById('connectBtn').onclick = async () => {
        try {
            port = await navigator.serial.requestPort();
            await port.open({ baudRate: 115200 });
            writer = port.writable.getWriter();
            startReading(port.readable.getReader());
            debugLog("Serial Connected.", "success");
            document.getElementById('flashBtn').disabled = false;
        } catch (e) { debugLog(`Error: ${e}`, "err"); }
    };

    document.getElementById('flashBtn').onclick = async () => {
        const fileInput = document.getElementById('hexFile');
        if (!fileInput.files.length) return;

        try {
            const { firmware, minAddr, maxAddr } = parseHex(await fileInput.files[0].text());
            rxBuffer = [];

            // Step 2-4: Bootloader Entry (省略せずに実装済み)
            debugLog("Step 2-3: Bootloader Mode", "step");
            const mspMsg = (cmd, data=[]) => {
                let p = [0x24, 0x58, 0x3C, data.length, cmd & 0xFF, (cmd >> 8) & 0xFF];
                p.push(...data);
                // 簡易CRC
                let crc = 0;
                for(let i=3; i<p.length; i++) { crc ^= p[i]; for(let j=0; j<8; j++) crc = (crc&0x80)?(crc<<1)^0xD5:crc<<1; }
                p.push(crc & 0xFF);
                return new Uint8Array(p);
            };
            
            // パススルーとブートコマンド
            await writer.write(new Uint8Array([0x24,0x58,0x3C,0x00,0xF5,0x00,0x02,0x00,0xFE,0x11,0x12]));
            await sleep(1000);
            await writer.write(new Uint8Array([0x24,0x58,0x3C,0x00,0x44,0x00,0x00,0x00,0x06]));
            await sleep(2000);
            rxBuffer = [];

            debugLog("Step 4: Sync", "step");
            await writer.write(new Uint8Array([0x7F]));
            if (!await waitResponse(0x79)) throw new Error("Sync Failed");

            debugLog("Step 6: Erasing...", "step");
            const PAGE_SIZE = 2048;
            const startP = Math.floor((minAddr - 0x08000000) / PAGE_SIZE);
            const endP = Math.floor((maxAddr - 0x08000000 - 1) / PAGE_SIZE);
            let pList = []; for(let i=startP; i<=endP; i++) pList.push(i);

            await writer.write(new Uint8Array([0x44, 0xBB]));
            await waitResponse(0x79);
            let ePL = [(pList.length-1 >> 8) & 0xFF, (pList.length-1) & 0xFF];
            pList.forEach(p => { ePL.push((p >> 8) & 0xFF); ePL.push(p & 0xFF); });
            await writer.write(new Uint8Array([...ePL, calcCS(ePL)]));
            if (!await waitResponse(0x79, 10000)) throw new Error("Erase Timeout");

            await sleep(1000); // 消去後の安定待ち

            debugLog("Step 7: Writing Memory", "step");
            const CHUNK = 128; // 8の倍数
            for (let i = 0; i < firmware.length; i += CHUNK) {
                let chunk = firmware.slice(i, i + CHUNK);
                if (chunk.length % 8 !== 0) {
                    let tmp = new Uint8Array(Math.ceil(chunk.length / 8) * 8).fill(0xFF);
                    tmp.set(chunk); chunk = tmp;
                }
                const addr = minAddr + i;

                await writer.write(new Uint8Array([0x31, 0xCE]));
                await waitResponse(0x79);

                const aB = [(addr >> 24) & 0xFF, (addr >> 16) & 0xFF, (addr >> 8) & 0xFF, addr & 0xFF];
                await writer.write(new Uint8Array([...aB, calcCS(aB)]));
                if (!await waitResponse(0x79)) throw new Error(`Addr NACK at 0x${addr.toString(16)}`);

                const dPL = [chunk.length - 1, ...chunk];
                await writer.write(new Uint8Array([...dPL, calcCS(dPL)]));
                if (!await waitResponse(0x79)) throw new Error("Data NACK");

                if (i % 4096 === 0) debugLog(`Progress: ${Math.round((i/firmware.length)*100)}%`);
            }
            debugLog("--- FLASH SUCCESSFUL ---", "success");
        } catch (e) { debugLog(`FATAL: ${e.message}`, "err"); }
    };
    document.getElementById('clearLogBtn').onclick = () => logDiv.innerHTML = '';
});
</script>
</body>
</html>
