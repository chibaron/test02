<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OpenOSD-X Web Flasher</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #1e1e1e; color: #d4d4d4; padding: 20px; line-height: 1.5; }
        .container { max-width: 1000px; margin: auto; background: #252526; padding: 25px; border-radius: 8px; border: 1px solid #444; }
        h2 { color: #569cd6; margin-top: 0; border-bottom: 1px solid #444; padding-bottom: 10px; }
        .card { background: #333; padding: 15px; border-radius: 6px; margin-bottom: 20px; border: 1px solid #444; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        
        #log { 
            width: 100%; height: 400px; background: #000; color: #dcdcdc; 
            padding: 12px; font-family: 'Consolas', 'Monaco', monospace; overflow-y: scroll; 
            white-space: pre-wrap; border: 1px solid #333; font-size: 13px; line-height: 1.4;
        }

        .success { color: #6a9955; font-weight: bold; }
        .err { color: #f44747; font-weight: bold; }
        .info { color: #808080; }
        .step { color: #ce9178; font-weight: bold; border-left: 3px solid #ce9178; padding-left: 8px; margin-top: 10px; display: block; }

        select, input[type="file"] { width: 100%; background: #252526; border: 1px solid #555; color: white; padding: 8px; border-radius: 4px; box-sizing: border-box; }
        button { 
            padding: 12px; cursor: pointer; border: none; border-radius: 4px; 
            background: #0e639c; color: white; font-weight: bold; width: 100%; transition: 0.2s;
        }
        button:hover { background: #1177bb; }
        button:disabled { background: #3a3d41; color: #757575; cursor: not-allowed; }
        
        .progress-container { 
            height: 30px; background: #333; margin: 15px 0; border-radius: 4px; 
            overflow: hidden; position: relative; border: 1px solid #555;
        }
        #progressFill { height: 100%; background: #2d8a49; width: 0%; transition: width 0.1s ease; }
        #progressText {
            position: absolute; width: 100%; text-align: center; left: 0; top: 0;
            line-height: 30px; font-size: 14px; font-weight: bold; color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
    </style>
</head>
<body>

<div class="container">
    <h2>OpenOSD-X Web Flasher <small style="font-size: 0.4em; color: #888;">(STMicroelectronics G4 Series)</small></h2>
    
    <div class="card">
        <label>1. Firmware Source</label><br>
        <div class="grid" style="margin-top:8px;">
            <div>
                <small style="color: #aaa;">GitHub Releases:</small>
                <select id="githubSelect">
                    <option value="">Loading releases...</option>
                </select>
            </div>
            <div>
                <small style="color: #aaa;">Local File:</small>
                <input type="file" id="hexFile" accept=".hex">
            </div>
        </div>
    </div>

    <div class="card grid">
        <button id="connectBtn">CONNECT PORT</button>
        <button id="flashBtn" disabled style="background: #2d8a49;">EXECUTE FLASHING</button>
    </div>
    
    <div class="progress-container">
        <div id="progressFill"></div>
        <div id="progressText">0%</div>
    </div>

    <div id="log"></div>
</div>

<script>
const GITHUB_REPO = "OpenOSD-X/OpenOSD-X";
const PROXY_BASE = "https://corsproxy.io/?";
const BOOT_CMD = { GET_ID: 0x02, WRITE_MEMORY: 0x31, EXTENDED_ERASE: 0x44, ACK: 0x79, NACK: 0x1F };
const G4_CONF = { FLASH_BASE: 0x08000000, PAGE_SIZE: 2048, WRITE_CHUNK: 32 };

let port, writer, reader, readIteration = true;
let rxBuffer = [];

const sleep = (ms) => new Promise(res => setTimeout(res, ms));
const calcCS = (data) => data.reduce((a, b) => a ^ b, 0) & 0xFF;

function debugLog(msg, type = '') {
    const log = document.getElementById('log');
    const div = document.createElement('div');
    div.className = type;
    const now = new Date().toLocaleTimeString('en-US', { hour12: false });
    div.textContent = `[${now}] ${msg}`;
    log.appendChild(div);
    log.scrollTop = log.scrollHeight;
}

// GitHub API: Fetch Latest Release HEX files
async function loadReleases() {
    const select = document.getElementById('githubSelect');
    try {
        const apiUrl = `https://api.github.com/repos/${GITHUB_REPO}/releases/latest`;
        const response = await fetch(`${PROXY_BASE}${encodeURIComponent(apiUrl)}`);
        if (!response.ok) throw new Error("Failed to fetch release info");
        
        const data = await response.json();
        const hexAssets = data.assets.filter(a => a.name.endsWith('.hex'));
        
        select.innerHTML = '<option value="">-- Select from GitHub --</option>';
        hexAssets.forEach(asset => {
            const opt = document.createElement('option');
            opt.value = asset.browser_download_url;
            opt.textContent = `${asset.name} (${data.tag_name})`;
            select.appendChild(opt);
        });
        debugLog(`Loaded ${hexAssets.length} assets from GitHub (${data.tag_name})`, "success");
    } catch (e) {
        select.innerHTML = '<option value="">Error loading releases</option>';
        debugLog("GITHUB API ERROR: " + e.message, "err");
    }
}

async function fetchHex(url) {
    debugLog(`Downloading: ${url}`, "info");
    try {
        const response = await fetch(`${PROXY_BASE}${encodeURIComponent(url)}`);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        return await response.text();
    } catch (e) {
        throw new Error(`Download Failed: ${e.message}`);
    }
}

async function readLoop() {
    try {
        while (readIteration) {
            const { value, done } = await reader.read();
            if (done) break;
            if (value) rxBuffer.push(...value);
        }
    } catch (e) { if (readIteration) debugLog("READER ERROR: " + e.message, "err"); }
    finally { if (reader) reader.releaseLock(); }
}

async function waitACK(timeout = 2000) {
    const start = Date.now();
    while (Date.now() - start < timeout) {
        if (rxBuffer.length > 0) {
            const b = rxBuffer.shift();
            if (b === BOOT_CMD.ACK) return true;
            if (b === BOOT_CMD.NACK) return false;
        }
        await sleep(2);
    }
    return false;
}

async function closePort() {
    debugLog("Releasing port...", "info");
    readIteration = false; 
    try {
        if (reader) await reader.cancel();
        if (writer) writer.releaseLock();
        if (port) await port.close();
        debugLog("DISCONNECTED.", "success");
    } catch (e) { debugLog("PORT ERROR: " + e.message, "err"); }
    document.getElementById('flashBtn').disabled = true;
    port = null; writer = null; reader = null;
}

function mspCRC(data) {
    let crc = 0;
    for (let b of data) {
        crc ^= b;
        for (let i = 0; i < 8; i++) crc = (crc & 0x80) ? (crc << 1) ^ 0xD5 : crc << 1;
    }
    return crc & 0xFF;
}

function parseHex(text) {
    const lines = text.split(/\r?\n/);
    let memory = new Map(), minAddr = 0xFFFFFFFF, maxAddr = 0, baseAddr = 0;
    for (let line of lines) {
        line = line.trim();
        if (!line.startsWith(':')) continue;
        const len = parseInt(line.substring(1, 3), 16);
        const offset = parseInt(line.substring(3, 7), 16);
        const type = parseInt(line.substring(7, 9), 16);
        if (type === 0x00) {
            const abs = baseAddr + offset;
            const data = line.substring(9, 9 + len * 2).match(/.{1,2}/g).map(h => parseInt(h, 16));
            data.forEach((b, i) => memory.set(abs + i, b));
            minAddr = Math.min(minAddr, abs);
            maxAddr = Math.max(maxAddr, abs + len);
        } else if (type === 0x04) baseAddr = parseInt(line.substring(9, 13), 16) << 16;
    }
    return { memory, minAddr, maxAddr };
}

document.getElementById('connectBtn').onclick = async () => {
    try {
        rxBuffer = []; readIteration = true;
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });
        writer = port.writable.getWriter();
        reader = port.readable.getReader();
        readLoop();
        debugLog("CONNECTED.", "success");
        document.getElementById('flashBtn').disabled = false;
    } catch (e) { debugLog("CONN ERROR: " + e.message, "err"); }
};

document.getElementById('flashBtn').onclick = async () => {
    const ghUrl = document.getElementById('githubSelect').value;
    const localFile = document.getElementById('hexFile').files[0];
    let hexText = "";

    try {
        if (ghUrl) {
            hexText = await fetchHex(ghUrl);
        } else if (localFile) {
            hexText = await localFile.text();
        } else {
            alert("Please select a firmware source.");
            return;
        }

        debugLog("--- STARTING FLASH ---", "step");
        const { memory, minAddr, maxAddr } = parseHex(hexText);
        debugLog(`IMAGE: 0x${minAddr.toString(16).toUpperCase()} - 0x${maxAddr.toString(16).toUpperCase()} (${maxAddr-minAddr} bytes)`, "info");

        // Initialization
        await writer.write(new Uint8Array([...[0x24, 0x58, 0x3C, 0x00, 0xF5, 0x00, 0x02, 0x00, 0xFE, 0x11], mspCRC([0x00, 0xF5, 0x00, 0x02, 0x00, 0xFE, 0x11])]));
        await sleep(1000);
        await writer.write(new Uint8Array([...[0x24, 0x58, 0x3C, 0x00, 0x44, 0x00, 0x00, 0x00], mspCRC([0x00, 0x44, 0x00, 0x00, 0x00])]));
        await sleep(1500);
        rxBuffer = [];

        // Sync
        let synced = false;
        for(let i=0; i<5; i++) {
            await writer.write(new Uint8Array([0x7F]));
            if (await waitACK(500)) { synced = true; break; }
        }
        if (!synced) throw new Error("SYNC FAILED.");

        // Erase & Write
        const startPage = Math.floor((minAddr - G4_CONF.FLASH_BASE) / G4_CONF.PAGE_SIZE);
        const endPage = Math.floor((maxAddr - G4_CONF.FLASH_BASE - 1) / G4_CONF.PAGE_SIZE);
        debugLog("ERASING...", "info");
        for (let p = startPage; p <= endPage; p++) {
            await writer.write(new Uint8Array([BOOT_CMD.EXTENDED_ERASE, 0xBB]));
            await waitACK();
            const pay = [0x00, 0x00, (p >> 8) & 0xFF, p & 0xFF];
            await writer.write(new Uint8Array([...pay, calcCS(pay)]));
            await waitACK(5000);
        }

        debugLog("WRITING...", "info");
        const totalSize = maxAddr - minAddr;
        let written = 0;
        for (let addr = minAddr; addr < maxAddr; addr += G4_CONF.WRITE_CHUNK) {
            const chunk = [];
            for (let j = 0; j < G4_CONF.WRITE_CHUNK; j++) chunk.push(memory.get(addr + j) ?? 0xFF);
            await writer.write(new Uint8Array([BOOT_CMD.WRITE_MEMORY, 0xCE])); await waitACK();
            const aB = [(addr >> 24) & 0xFF, (addr >> 16) & 0xFF, (addr >> 8) & 0xFF, addr & 0xFF];
            await writer.write(new Uint8Array([...aB, calcCS(aB)])); await waitACK();
            const dPL = [chunk.length - 1, ...chunk];
            await writer.write(new Uint8Array([...dPL, calcCS(dPL)])); await waitACK();
            
            written += chunk.length;
            const pct = Math.floor((written / totalSize) * 100);
            document.getElementById('progressFill').style.width = pct + "%";
            document.getElementById('progressText').textContent = `${pct}% (${written}/${totalSize})`;
        }

        debugLog("SUCCESS!", "success");
        alert("COMPLETED.");
    } catch (e) {
        debugLog("FATAL: " + e.message, "err");
        alert("ERROR: " + e.message);
    } finally { await closePort(); }
};

// Start Up
loadReleases();
</script>
</body>
</html>
