<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OpenOSD-X Web Flasher</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #1e1e1e; color: #d4d4d4; padding: 20px; line-height: 1.5; }
        .container { max-width: 1000px; margin: auto; background: #252526; padding: 25px; border-radius: 8px; border: 1px solid #444; }
        h2 { color: #569cd6; margin-top: 0; border-bottom: 1px solid #444; padding-bottom: 10px; }
        .card { background: #333; padding: 15px; border-radius: 6px; margin-bottom: 20px; border: 1px solid #444; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        
        #log { 
            width: 100%; height: 450px; background: #000; color: #dcdcdc; 
            padding: 12px; font-family: 'Consolas', 'Monaco', monospace; overflow-y: scroll; 
            white-space: pre-wrap; border: 1px solid #333; font-size: 13px; line-height: 1.4;
        }

        .success { color: #6a9955; font-weight: bold; }
        .err { color: #f44747; font-weight: bold; }
        .info { color: #808080; }
        .step { color: #ce9178; font-weight: bold; border-left: 3px solid #ce9178; padding-left: 8px; margin-top: 10px; display: block; }

        input[type="text"] { width: 100%; background: #252526; border: 1px solid #555; color: white; padding: 8px; border-radius: 4px; box-sizing: border-box; }
        button { 
            padding: 12px; cursor: pointer; border: none; border-radius: 4px; 
            background: #0e639c; color: white; font-weight: bold; width: 100%; transition: 0.2s;
        }
        button:hover { background: #1177bb; }
        button:disabled { background: #3a3d41; color: #757575; cursor: not-allowed; }
        
        .progress-container { 
            height: 30px; background: #333; margin: 15px 0; border-radius: 4px; 
            overflow: hidden; position: relative; border: 1px solid #555;
        }
        #progressFill { height: 100%; background: #2d8a49; width: 0%; transition: width 0.1s ease; }
        #progressText {
            position: absolute; width: 100%; text-align: center; left: 0; top: 0;
            line-height: 30px; font-size: 14px; font-weight: bold; color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
    </style>
</head>
<body>

<div class="container">
    <h2>OpenOSD-X Web Flasher <small style="font-size: 0.4em; color: #888;">(STMicroelectronics G4 Series)</small></h2>
    
    <div class="card">
        <label>1. Firmware Input (File or URL)</label><br>
        <div class="grid" style="margin-top:8px;">
            <input type="file" id="hexFile" accept=".hex">
            <input type="text" id="hexUrl" placeholder="https://github.com/.../firmware.hex">
        </div>
        <div style="margin-top:10px; font-size: 0.8em; color: #888;">*URL input will use a CORS proxy to fetch.</div>
    </div>

    <div class="card grid">
        <button id="connectBtn">CONNECT PORT</button>
        <button id="flashBtn" disabled style="background: #2d8a49;">EXECUTE FLASHING</button>
    </div>
    
    <div class="progress-container">
        <div id="progressFill"></div>
        <div id="progressText">0%</div>
    </div>

    <div id="log"></div>
</div>

<script>
const BOOT_CMD = { GET_ID: 0x02, WRITE_MEMORY: 0x31, EXTENDED_ERASE: 0x44, ACK: 0x79, NACK: 0x1F };
const G4_CONF = { FLASH_BASE: 0x08000000, PAGE_SIZE: 2048, WRITE_CHUNK: 32 };

let port, writer, reader, readIteration = true;
let rxBuffer = [];

const sleep = (ms) => new Promise(res => setTimeout(res, ms));
const calcCS = (data) => data.reduce((a, b) => a ^ b, 0) & 0xFF;

function debugLog(msg, type = '') {
    const log = document.getElementById('log');
    const div = document.createElement('div');
    div.className = type;
    const now = new Date().toLocaleTimeString('en-US', { hour12: false });
    div.textContent = `[${now}] ${msg}`;
    log.appendChild(div);
    log.scrollTop = log.scrollHeight;
}

// Fetch helper with CORS proxy
async function fetchHex(url) {
    debugLog(`Fetching from URL: ${url}`, "info");
    // Using corsproxy.io as a public bypass
    const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
    try {
        const response = await fetch(proxyUrl);
        if (!response.ok) throw new Error(`HTTP Error: ${response.status}`);
        return await response.text();
    } catch (e) {
        throw new Error(`CORS Fetch Failed: ${e.message}`);
    }
}

async function readLoop() {
    try {
        while (readIteration) {
            const { value, done } = await reader.read();
            if (done) break;
            if (value) rxBuffer.push(...value);
        }
    } catch (e) { 
        if (readIteration) debugLog("READER ERROR: " + e.message, "err"); 
    } finally {
        if (reader) reader.releaseLock();
    }
}

async function waitACK(timeout = 2000) {
    const start = Date.now();
    while (Date.now() - start < timeout) {
        if (rxBuffer.length > 0) {
            const b = rxBuffer.shift();
            if (b === BOOT_CMD.ACK) return true;
            if (b === BOOT_CMD.NACK) return false;
        }
        await sleep(2);
    }
    return false;
}

async function closePort() {
    debugLog("Releasing port resources...", "info");
    readIteration = false; 
    try {
        if (reader) await reader.cancel();
        if (writer) writer.releaseLock();
        if (port) await port.close();
        debugLog("PORT DISCONNECTED.", "success");
    } catch (e) {
        debugLog("DISCONNECTION ERROR: " + e.message, "err");
    }
    document.getElementById('flashBtn').disabled = true;
    port = null; writer = null; reader = null;
}

function mspCRC(data) {
    let crc = 0;
    for (let b of data) {
        crc ^= b;
        for (let i = 0; i < 8; i++) {
            crc = (crc & 0x80) ? (crc << 1) ^ 0xD5 : crc << 1;
        }
    }
    return crc & 0xFF;
}

function parseHex(text) {
    const lines = text.split(/\r?\n/);
    let memory = new Map(), minAddr = 0xFFFFFFFF, maxAddr = 0, baseAddr = 0;
    for (let line of lines) {
        line = line.trim();
        if (!line.startsWith(':')) continue;
        const len = parseInt(line.substring(1, 3), 16);
        const offset = parseInt(line.substring(3, 7), 16);
        const type = parseInt(line.substring(7, 9), 16);
        if (type === 0x00) {
            const abs = baseAddr + offset;
            const data = line.substring(9, 9 + len * 2).match(/.{1,2}/g).map(h => parseInt(h, 16));
            data.forEach((b, i) => memory.set(abs + i, b));
            minAddr = Math.min(minAddr, abs);
            maxAddr = Math.max(maxAddr, abs + len);
        } else if (type === 0x04) {
            baseAddr = parseInt(line.substring(9, 13), 16) << 16;
        }
    }
    return { memory, minAddr, maxAddr };
}

document.getElementById('connectBtn').onclick = async () => {
    try {
        rxBuffer = [];
        readIteration = true;
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });
        writer = port.writable.getWriter();
        reader = port.readable.getReader();
        readLoop();
        debugLog("OPENOSD-X CONNECTED.", "success");
        document.getElementById('flashBtn').disabled = false;
    } catch (e) { debugLog("CONNECTION ERROR: " + e.message, "err"); }
};

document.getElementById('flashBtn').onclick = async () => {
    const fileInput = document.getElementById('hexFile');
    const urlInput = document.getElementById('hexUrl').value.trim();
    let hexText = "";

    try {
        if (urlInput) {
            hexText = await fetchHex(urlInput);
        } else if (fileInput.files[0]) {
            hexText = await fileInput.files[0].text();
        } else {
            alert("Please select a file or enter a URL.");
            return;
        }

        debugLog("--- STARTING FLASH SEQUENCE ---", "step");
        const { memory, minAddr, maxAddr } = parseHex(hexText);
        debugLog(`LOADED: 0x${minAddr.toString(16).toUpperCase()} - 0x${maxAddr.toString(16).toUpperCase()} (${maxAddr-minAddr} bytes)`, "info");

        // Flash Logic (Same as before)
        debugLog("INITIALIZING BRIDGE...", "info");
        let p = [0x24, 0x58, 0x3C, 0x00, 0xF5, 0x00, 0x02, 0x00, 0xFE, 0x11];
        p.push(mspCRC(p.slice(3, 10)));
        await writer.write(new Uint8Array(p));
        await sleep(1000);

        debugLog("INVOKING BOOTLOADER...", "info");
        let b = [0x24, 0x58, 0x3C, 0x00, 0x44, 0x00, 0x00, 0x00];
        b.push(mspCRC(b.slice(3, 8)));
        await writer.write(new Uint8Array(b));
        await sleep(1500);
        rxBuffer = []; 

        debugLog("SYNCHRONIZING UART...", "info");
        let synced = false;
        for(let i=0; i<5; i++) {
            await writer.write(new Uint8Array([0x7F]));
            if (await waitACK(500)) { synced = true; break; }
        }
        if (!synced) throw new Error("SYNC FAILED.");

        await writer.write(new Uint8Array([BOOT_CMD.GET_ID, BOOT_CMD.GET_ID ^ 0xFF]));
        if (!await waitACK()) throw new Error("ID REJECTED.");
        while(rxBuffer.length < 1) await sleep(5);
        const idLen = rxBuffer.shift();
        for(let i=0; i<=idLen; i++) {
            while(rxBuffer.length < 1) await sleep(5);
            rxBuffer.shift();
        }
        await waitACK(); 

        const startPage = Math.floor((minAddr - G4_CONF.FLASH_BASE) / G4_CONF.PAGE_SIZE);
        const endPage = Math.floor((maxAddr - G4_CONF.FLASH_BASE - 1) / G4_CONF.PAGE_SIZE);
        debugLog(`ERASING FLASH...`, "step");

        for (let p = startPage; p <= endPage; p++) {
            await writer.write(new Uint8Array([BOOT_CMD.EXTENDED_ERASE, BOOT_CMD.EXTENDED_ERASE ^ 0xFF]));
            if (!await waitACK()) throw new Error(`ERASE FAILED AT PAGE ${p}`);
            const payload = [0x00, 0x00, (p >> 8) & 0xFF, p & 0xFF];
            await writer.write(new Uint8Array([...payload, calcCS(payload)]));
            if (!await waitACK(5000)) throw new Error(`ERASE TIMEOUT AT PAGE ${p}`);
        }

        debugLog("WRITING FIRMWARE...", "step");
        const totalSize = maxAddr - minAddr;
        let written = 0;
        let lastLogPercent = -10;

        for (let addr = minAddr; addr < maxAddr; addr += G4_CONF.WRITE_CHUNK) {
            const chunk = [];
            for (let j = 0; j < G4_CONF.WRITE_CHUNK; j++) {
                chunk.push(memory.get(addr + j) ?? 0xFF);
            }
            await writer.write(new Uint8Array([BOOT_CMD.WRITE_MEMORY, BOOT_CMD.WRITE_MEMORY ^ 0xFF]));
            if (!await waitACK()) throw new Error("WRITE CMD NACK.");
            const aB = [(addr >> 24) & 0xFF, (addr >> 16) & 0xFF, (addr >> 8) & 0xFF, addr & 0xFF];
            await writer.write(new Uint8Array([...aB, calcCS(aB)]));
            if (!await waitACK()) throw new Error(`ADDR ERROR AT 0x${addr.toString(16)}`);
            const dPL = [chunk.length - 1, ...chunk];
            await writer.write(new Uint8Array([...dPL, calcCS(dPL)]));
            if (!await waitACK()) throw new Error(`DATA ERROR AT 0x${addr.toString(16)}`);

            written += chunk.length;
            const percent = Math.floor((written / totalSize) * 100);
            document.getElementById('progressFill').style.width = `${percent}%`;
            document.getElementById('progressText').textContent = `${percent}% (${written}/${totalSize})`;

            if (percent >= lastLogPercent + 10) {
                debugLog(`FLASH PROGRESS: ${percent}%`, "info");
                lastLogPercent = percent;
            }
        }

        debugLog("FLASH COMPLETED SUCCESSFULLY!", "success");
        alert("FLASHING COMPLETED.");

    } catch (e) {
        debugLog("FATAL ERROR: " + e.message, "err");
        alert("ERROR: " + e.message);
    } finally {
        await closePort();
    }
};
</script>
</body>
</html>
